<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body {
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    }

    #chart{
      width: 600px;
      height: 400px;

      border: solid 1px #CCC;
    }

    #legend {
      width: 600px;
      padding: 0;
    }

    .topic {
      display: inline-block;
      padding: 5px 10px;
      margin: 0 5px;
      border: solid 1px #AAA;
    }

    .topic:first-child {
      margin-left: 0;
    }

    .topic.active {
      background: #E9E9E9;
    }

    textarea {
      width: 600px;
    }
  </style>
</head>
<body>
  <div id="chart"></div>
  <ul id="legend"></ul>
  <textarea></textarea>
  <!--
  <script src="https://d3js.org/d3.v5.js"></script>
  -->
  <script src="./d3.v5.js"></script>
  <script>

    async function fetchData() {

      var idx = Math.floor(Math.random() * 6);

      idx = 0;

      console.log(`loading data-${ idx }.json`);

      var {
        brokers
      } = await d3.json(`data-${idx}.json`);

      var topicMap = {};
      var partitionMap = {};

      brokers.forEach(function(broker) {

        // generate synthetic broker ID
        broker.id = `${broker.host}:${broker.port}`;

        broker.memberships = [];

        // load partitions
        broker.partitions.forEach(membership => {

          var topic = topicMap[membership.topicName];

          // create topic
          if (!topic) {
            topic = topicMap[membership.topicName] = {
              id: membership.topicName,
              partitions: []
            };
          }

          var partition = partitionMap[membership.partitionId];

          if (!partition) {
            partition = partitionMap[membership.partitionId] = {
              id: membership.partitionId,
              members: []
            };

            // wire partition -> topic
            partition.topic = topic;

            // add partition
            topic.partitions.push(
              partition
            );
          }

          var partitionMembership = {
            broker,
            partition,
            role: membership.role
          };

          partition.members.push(partitionMembership);

          broker.memberships.push(partitionMembership);
        });

      });

      return {
        brokers,
        partitions: Object.values(partitionMap),
        topics: Object.values(topicMap)
      };
    }


    const ACTIVE_CLS = 'active';

    let brokers = [];
    let partitions = [];
    let topics = [];

    async function run() {

      var colors = d3.scaleOrdinal(d3.schemeCategory10);

      var visibleGroups = [];

      // LAYOUT
      var width = 600;
      var height = 400;

      var svg =
        d3.select('#chart')
          .append('svg')
            .attr('width', width)
            .attr('height', height);

      var hullGroup = svg.append('g');
      var nodeGroup = svg.append('g');

      var pie = d3.pie().value(_ => 1);

      var arcGroup = svg.append('g')
        .attr('class', 'pie')
        .attr('transform', 'translate(100, 100)');

      var arcPath = d3.arc()
        .outerRadius(15)
        .innerRadius(0);

      function groupColor(group) {
        return group.color || '#ccc';
      }

      function membershipColor(membership) {
        return colors(membership.partition.id) || '#ccc';
      }

      // UPDATE VISUALS
      function tick() {

        var hull =
          hullGroup.selectAll('.hull')
            .data(visibleGroups);

        var hullEnter =
          hull.enter()
            .append('path')
              .classed('hull', true)
              .style('stroke-width', 10)
              .style('stroke-linejoin', 'round')
              .style('opacity', .2);

        hull.exit().remove();

        hull.merge(hullEnter)
          .style('fill', groupFill)
          .style('stroke', groupFill)
          .attr('d', groupPath);


        var node =
          nodeGroup.selectAll('.node')
            .data(brokers);

        var nodeEnter =
          node.enter()
            .append('g')
              .attr('class', 'node');

        var circle = nodeEnter
          .append('g')
            .attr('class', 'circle');

        var arc = circle
          .selectAll('.arc')
          .data(function(broker) {
            return pie(broker.memberships);
          })
          .enter()
            .append("path")
              .attr("class", "arc")
              .attr("d", arcPath)
              .style('fill', function(d) {
                return membershipColor(d.data);
              });

        nodeEnter.append('text')
          .attr('dx', 20)
          .attr('dy', '.35em')
          .text(function(d) { return d.id; });

        node.merge(nodeEnter)
          .attr('transform', function(d) {
            return `translate(${d.x},${d.y})`;
          })
          .on('click', clickNode);

        node.exit().remove();


        var legend = d3.select("#legend")
          .selectAll('.topic')
            .data(topics);

        legend.enter()
          .append('li')
            .attr('data-topic-id', t => t.id)
            .on('click', clickTopic)
            .style('color', function(d) {
              return d.color;
            })
            .classed('topic', true)
            .text(function(t) {
              return `topic ${t.id}`;
            });

        legend.exit().remove();
      }

      function showPartitions(topics) {

        var links = [];

        var linkMap = new Map();

        topics.forEach((topic) => {
          var l = getTopicLinks(topic);

          linkMap.set(topic, l);

          links = links.concat(l);
        });

        simulation.alpha(0.3).restart();

        linkForce.links(links);

        visibleGroups = [ ...linkMap ].map(([ topic, links ]) => {
          var nodeSet = new Set();

          links.forEach(function(l) {
            nodeSet.add(l.source);
            nodeSet.add(l.target);
          });

          return {
            nodes: [ ...nodeSet ],
            topic
          };
        });
      }

      function getPartitionLinks(partition) {

        var members = partition.members;

        var leadership = (
          members.find(m => m.role === 'LEADER') ||
          members[0]
        );

        return members.map(membership => {

          if (membership === leadership) {
            return;
          }

          return {
            source: leadership.broker,
            target: membership.broker
          };
        }).filter(n => n);
      }

      function getTopicLinks(topic) {

        var {
          partitions
        } = topic;

        var partitionLinks = partitions.map(getPartitionLinks);

        return [].concat(...partitionLinks);
      }

      function nodeHull({ nodes, topic }) {

        var g = nodes.map(n => ({
          x: n.x,
          y: n.y
        }));

        nodes.forEach(function(n, j) {
            var alpha = (2 * Math.PI * j / 5);
            var dummy = {
              x: n.x + 10 * Math.sin(alpha),
              y: n.y + 10 * Math.cos(alpha)
            };
            g.push(dummy);
        });

        return {
          nodes: g,
          color: topic && topic.color || '#ccc'
        };
      }

      function groupFill(group) {
        return groupColor(group);
      }

      function groupPath(group) {

        var {
          nodes
        } = group;

        var points = nodes.reduce((points, point) => {

          const pad = 30;
          const parts = 9;

          for (var j = 0; j <= parts; j++) {
            var alpha = (2 * Math.PI * j / parts);

            points.push([
              point.x + pad * Math.sin(alpha),
              point.y + pad * Math.cos(alpha)
            ]);
          }

          return points;
        }, []);

        return 'M' +
          d3.polygonHull(points).join('L')
        + 'Z';
      }

      var linkForce =
        d3.forceLink()
          .id(t => t.id)
          .strength(.7);

      var simulation =
        d3.forceSimulation()
          .force('center', d3.forceCenter(
            width / 2,
            height / 2
          ))
          .force('body',
            d3.forceManyBody()
              .distanceMax(120)
              .strength(-50)
          )
          .force('collide', d3.forceCollide(30))
          .force('link', linkForce)
          .on('tick', tick);


      function clickTopic(topic, _, selection) {

        var clickedEl = d3.select(this);

        var active = clickedEl.classed(ACTIVE_CLS);

        // remove active selection from all
        d3.selectAll(selection).classed(ACTIVE_CLS, false);

        clickedEl.classed(ACTIVE_CLS, !active);

        showPartitions(!active ? [ topic ] : []);
      }


      function clickNode(node) {

        d3.selectAll('.topic').classed(ACTIVE_CLS, false);

        if (partitions.length) {
          showPartitions([]);
        }

        var selectedTopics = topics.filter((topic) => {
          return topic.partitions.find((partition) => {
            return partition.node === node.id;
          });
        });

        // showPartitions(selectedTopics);
      }

      function reload() {

        fetchData().then(function(data) {

          brokers = data.brokers;
          partitions = data.partitions;
          topics = data.topics;

          // TODO refresh links
          // REFRESH visual groups
          simulation.nodes(brokers);
        });

      }

      reload();
    }

    run().catch(console.error);
  </script>
</body>
</html>